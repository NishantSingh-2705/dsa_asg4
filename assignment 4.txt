#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int choice = 1; // input choice

struct node
{
    char fname[15];
    char lname[15];
    int age;
    int year;
    struct node*next;
} *front = NULL,*rear=NULL,*front2=NULL,*rear2=NULL,*top=NULL,*prev;

//FILE HANDLING-------------------------START-----------------------------------------------
int entryCount;
typedef struct
{
    char *f_name;
    char *l_name;
    int age_i;
    int year_i;
} Entry;

//FILE HANDLING-------------------------END-------------------------------------------------

//function declarations(prototypes)----------------------------------------------------------
void enq(char fn[],char ln[],int ag,int yr);
void enq2(char fn[],char ln[],int age2,int year2);
void enq3(char fn[],char ln[],int age4,int year4);
void dq();
void dq2();
void push(char fn[],char ln[],int age3,int year3);
void pop();
void reverse_stack();
void display_reverse();
void display_q();

//first enqueue function---------------------------------------------------------
int t=0;
void enq(char fn[],char ln[],int ag,int yr)
{

    struct node* newnode;
    newnode=(struct node *)(malloc(sizeof(struct node)));
    strcpy(newnode->fname,fn);
    strcpy(newnode->lname,ln);
    newnode->age = ag;
    newnode->year = yr;
    newnode->next=NULL;
    printf("Data Serial No.- %d\n",t+1);

    printf("%s %s,%d,%d\n",fn,ln,ag,yr);
    t++;
    if(front == NULL && rear == NULL)
    {
        front = rear = newnode;
    }
    else
    {
        rear->next=newnode;
        rear=newnode;
    }


}
//second enqueue function----------------------------------------------------------------------------------
void enq2(char fn[],char ln[],int age2,int year2)
{
    struct node* newnode;
    newnode=(struct node *)(malloc(sizeof(struct node)));

    strcpy(newnode->fname,fn);
    strcpy(newnode->lname,ln);
    newnode->age=age2;
    newnode->year=year2;
    newnode->next=NULL;

    if(front2 == NULL && rear2 == NULL)
    {
        front2 = rear2 = newnode;
    }
    else
    {
        rear2->next=newnode;
        rear2=newnode;
    }
}

// first dequeue function----------------------------------------------------------------
void dq()
{
    struct node *temp=front;
    if(front == NULL && rear == NULL)
    {
        printf("Queue is empty!\n");
        printf("-------------------------------------------------------------------\n");
        choice = 0;
    }
    else if(front == rear)
    {   printf("Dequeued Data: ");
        printf("%s %s,%d,%d\n",temp->fname,temp->lname,temp->age,temp->year);

        enq2(temp->fname,temp->lname,temp->age,temp->year);

        front = rear = NULL;
    }
    else
    {
        printf("Dequeued Data: ");
        printf("%s %s,%d,%d\n",temp->fname,temp->lname,temp->age,temp->year);
        enq2(temp->fname,temp->lname,temp->age,temp->year);
        front=front->next;
        free(temp);
    }
}

//second dequeue function--------------------------------------------------------------
void dq2()
{
    struct node *temp=front2;

    if(front2 == NULL && rear2 == NULL)
    {
        printf("Queue is empty!\n");
        printf("All data pushed successfully to stack\n");
        printf("-------------------------------------------------------------------\n");
        printf("Press 2 to reverse order of stack\n");
        printf("-------------------------------------------------------------------\n");

    }
    else if(front2 == rear2)
    {
        printf("Dequeued and pushed data to stack: ");
        printf("%s %s,%d,%d\n",temp->fname,temp->lname,temp->age,temp->year);
        push(temp->fname,temp->lname,temp->age,temp->year);    //push data to stack
        front2 = rear2 = NULL;
    }
    else
    {
        printf("Dequeued and pushed data to stack: ");
        printf("%s %s,%d,%d\n",temp->fname,temp->lname,temp->age,temp->year);
        push(temp->fname,temp->lname,temp->age,temp->year);   //push data to stack
        front2=front2->next;
        free(temp);
    }
}

//stack operations ---------------start----------------------------------------
//push function for stack------------------------------
void push(char fn[],char ln[],int age3,int year3)
{
    struct node * newdata;
    newdata=(struct node *)(malloc)(sizeof(struct node));

    //data initialization-------
    strcpy(newdata->fname,fn);
    strcpy(newdata->lname,ln);
    newdata->age=age3;
    newdata->year=year3;

    newdata->next=top;
    top=newdata;


}

//pop function for stack--------------------------------
void pop()
{

    struct node *temp=prev;
    if(temp==NULL)
    {
        printf("Stack is empty\n\n");

        printf("-------------------------------------------------------------------\n");
        printf("Press 4 to display the final data of Queue\n");
        printf("-------------------------------------------------------------------\n");
    }
    else
    {

    printf("The popped element is: %s %s,%d,%d \n",prev->fname,prev->lname,prev->age,prev->year);
    enq3(prev->fname,prev->lname,prev->age,prev->year);
    prev=prev->next;
    free(temp);
    }

}

//reverse function for stack-----------------------------------------------
void reverse_stack()
{
    struct node*current,*nextn;
    prev =NULL;
    current=nextn=top;
    while(nextn!=NULL)
    {
        nextn=nextn->next;
        current->next=prev;
        prev= current;
        current=nextn;
    }
    display_reverse();
}
//display reverse stack-----------------------------------------------------
void display_reverse()
{
    struct node*temp;
    temp= prev;
    printf("reversed data:\n");
    while(temp!=NULL)
    {
        printf("%s %s,%d,%d \n",temp->fname,temp->lname,temp->age,temp->year);
        temp=temp->next;
    }
    printf("-------------------------------------------------------------------\n");
    printf("Press 3 to pop and requeue data one after another:\n");
    printf("-------------------------------------------------------------------\n");
}


//stack operations ---------------end------------------------------------------

//third enqueue function-------------------------------------------------------
void enq3(char fn[],char ln[],int age4,int year4)
{
    struct node* newnode;
    newnode=(struct node *)(malloc(sizeof(struct node)));
    strcpy(newnode->fname,fn);
    strcpy(newnode->lname,ln);
    newnode->age=age4;
    newnode->year=year4;
    newnode->next=NULL;

    if(front == NULL && rear == NULL)
    {
        front = rear = newnode;
    }
    else
    {
        rear->next=newnode;
        rear=newnode;
    }

}

//display final Queue data----------------------------------------------------
void display_q()
{
    struct node *temp;
    temp=front;
    printf("Initial Queue is preserved\nFinal Queue data:\n");
    printf("-------------------------------------------------------------------\n");
    while (temp!=rear)
    {
        printf("%s %s,%d,%d \n",temp->fname,temp->lname,temp->age,temp->year);
        temp=temp->next;
    }
    printf("%s %s,%d,%d \n",temp->fname,temp->lname,temp->age,temp->year);
    choice = 0; //exit from loop
}


//main function----------------------------------------------------------------
int main()
{
    //file handling input--------------------start-----------------------------

    FILE *fp = fopen("input.txt","r");
    Entry *entries = malloc(sizeof(Entry) * entryCount);   //allocate number of inputs
    fscanf(fp, "%i" , &entryCount);

    for (int i = 0; i < entryCount; i++)
    {

        entries[i].f_name = malloc(sizeof(char));
        entries[i].l_name = malloc(sizeof(char));
        fscanf(fp,"%s %s %i %i",entries[i].f_name, entries[i].l_name,&entries[i].age_i,&entries[i].year_i);

    }



    //file handling input--------------------end-------------------------------

    char ch[1];   //choice for yes or no for stack processing
    // enqueue dequeue requeue ---------------start----------------------------

    printf("Press 1 to read data from file\nPress 0 to exit\n");
    printf("-------------------------------------------------------------------\n\n");
    int r=0;
    char fn[15],ln[15];
    int ag,yr;
    do
    {

        printf("Choice:");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:
                strcpy(fn,entries[r].f_name);
                strcpy(ln,entries[r].l_name);
                ag = entries[r].age_i;
                yr = entries[r].year_i;
            enq(fn,ln,ag,yr);
            if (r+1==entryCount)
                {
                    printf("\n");
                    printf("Data inputs Successfull");
                    printf("\n");
                   printf("-------------------------------------------------------------------\n");
                   printf("Press 2 to dequeue data\nPress 0 to exit\n");
                   printf("-------------------------------------------------------------------\n\n");
                   choice=0;
                }
            r++;
            break;
            case 0:
            return 0;
            default:
            printf("Please enter valid Input\n");
        }

    } while(choice);
//first dequeue-------------------------------------------------------------------------
do
    {

        printf("Choice:");
        scanf("%d",&choice);
        switch(choice)
        {


            case 2:
            dq();
            break;
            case 0:
            return 0;
            default:
            printf("Please enter valid Input\n");
        }

    } while(choice);

// enqueue dequeue requeue ---------------end----------------------------------------
printf("Press Y to continue processing or any key to exit:");
scanf("%s",ch);

// Queue to stack push pop and requeue-----------------------start-------------------



if (strcmp(ch,"Y") == 0 || strcmp(ch,"y") == 0)
{
    printf("-------------------------------------------------------------------\n");
    printf("Press 1 to dequeue and push element to stack one after another\nPress 0 to exit\n");
    printf("-------------------------------------------------------------------\n\n");
    do
    {
        printf("Choice:");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:
            dq2();
            break;
            case 2:
            reverse_stack();
            break;
            case 3:
            pop();
            break;
            case 4:
            display_q();
            case 0:
            break;
            default:
            printf("Please enter valid Input\n");
        }
    } while(choice);
}
else
{
    printf("-------------------------------------------------------------------\n");
    printf("Program Exited\n");
    return 0;
}

        printf("-------------------------------------------------------------------\n");
        printf("Press Y to continue or any key to exit\n");
        scanf("%s",ch);
        printf("-------------------------------------------------------------------\n");

// Queue to stack push pop and requeue-----------------------end-------------------


if (strcmp(ch,"Y") == 0 || strcmp(ch,"y") == 0)
{
    printf("Continue to code from here!\n");
}
else
{
    return 0;
}


    return 0;
}
